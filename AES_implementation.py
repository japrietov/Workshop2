# -*- coding: iso-8859-1 -*-


# Authors: Jeisson Andres Prieto Velandia
#          David Santiago Barrera

import re
import math
from itertools import repeat
import numpy as np

# Convert each letter to binary
def convert_letter_to_hex(char):
    return char.encode("hex")

# Subbytes operation
def subbytes(char):
    # Rijndael S-box
    sbox =  [
        [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
        [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
        [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
        [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
        [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
        [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
        [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
        [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
        [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
        [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
        [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
        [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
        [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
        [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
        [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
        [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]
    ]

    return sbox[int(char[0],16)][int(char[1],16)]

def inv_subbytes(char):
    # Rijndael inverse S-box
    sboxInv = [
        [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb],
        [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb],
        [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e],
        [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25],
        [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92],
        [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84],
        [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06],
        [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b],
        [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73],
        [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e],
        [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b],
        [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4],
        [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f],
        [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef],
        [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61],
        [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]
    ]
    return sboxInv[int(char[0], 16)][int(char[1], 16)]


# given Rcon Value for the key generator
def getRconValue(num):

    # Rijndael Rcon
    Rcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,
            0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97,
            0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72]
    return Rcon[num]

# key generator
def key_generator(key):
    # message_hex = np.array(np.array_split([convert_letter_to_hex(m) for m in message],4))
    tmp = re.findall('..', key)
    key_hex = np.array(np.array_split(tmp, 4))

    for i in xrange(4,44):
        W_i_4 = key_hex[i-4]
        W_i_1 = key_hex[i-1]

        if i%4 == 0:
            Rot_word = np.roll(W_i_1,-1)
            sub_bytes = "".join([hex(subbytes(w))[2:] if len(hex(subbytes(w))[2:]) == 2 else "0"+hex(subbytes(w))[2:] for w in Rot_word])
            Rcon = [hex(getRconValue(i/4))[2:] if len(hex(getRconValue(i/4))[2:]) == 2 else "0"+hex(getRconValue(i/4))[2:]] + list("000000")
            Rcon = "".join(re.findall('..', "".join(Rcon)))
            Xor_Rcon_sub_bytes = hex(int(Rcon,16) ^ int(sub_bytes,16))[2:].rstrip("L").rjust(8, '0')
            Xor_W1_W4 = hex(int(Xor_Rcon_sub_bytes,16) ^ int("".join(W_i_4),16))[2:].rstrip("L").rjust(8, '0')
            W_i = re.findall('..', Xor_W1_W4)
            key_hex = np.vstack([key_hex, W_i])
        else:
            Xor_W1_W4 = hex (int("".join(W_i_4), 16) ^ int("".join(W_i_1), 16))[2:].rstrip("L").rjust(8, '0')
            W_i = re.findall('..', Xor_W1_W4)
            key_hex = np.vstack([key_hex, W_i])
    dict_keys = {}
    matrix_keys = np.array(np.split(key_hex, 11))

    for key in xrange(11):
        dict_keys[key] = matrix_keys[key].T
    return dict_keys

# make state message
def make_state_message(message):
    return np.array(np.array_split([convert_letter_to_hex(m) for m in message],4)).T

# Convert a matrix hexadecimal into integer
def convert_hx_int(A):
    matrix_hx = []
    for row in A:
        tmp = []
        for col in row:
            tmp.append(int(col,16))
        matrix_hx.append(tmp)
    return np.array(matrix_hx)

# Convert a matrix decimal into hexadecimal
def convert_decimal_hx(A):
    matrix_decimal = []
    for row in A:
        tmp = []
        for col in row:
            tmp.append(hex(int(col))[2:] if len(hex(int(col))[2:]) == 2 else "0"+hex(int(col))[2:])
        matrix_decimal.append(tmp)
    return np.array(matrix_decimal)

# Add Round Key ARK
def add_round_key(A,B):
    ARK_matrix = []
    A, B = convert_hx_int(A), convert_hx_int(B)
    for row in xrange(len(A)):
        tmp_row = []
        for col in xrange(len(A)):
            tmp_row.append(A[row][col]^B[row][col])
        ARK_matrix.append(tmp_row)
    return convert_decimal_hx(np.array(ARK_matrix))

# subbytes matrix
def subbytes_matrix_convert(A):
    subbytes_matrix = []
    for row in A:
        tmp_col = []
        for col in row:
            tmp_col.append(hex(subbytes(col))[2:] if len(hex(subbytes(col))[2:]) == 2 else "0"+hex(subbytes(col))[2:])
        subbytes_matrix.append(tmp_col)

    return np.array(subbytes_matrix)


# inv subbytes matrix
def inv_subbytes_matrix_convert(A):
    inv_subbytes_matrix = []
    for row in A:
        tmp_col = []
        for col in row:
            tmp_col.append(hex(inv_subbytes(col))[2:] if len(hex(inv_subbytes(col))[2:]) == 2 else "0"+hex(inv_subbytes(col))[2:])
        inv_subbytes_matrix.append(tmp_col)

    return np.array(inv_subbytes_matrix)

# shiftRow
def shift_row(A):
    matrix_shift = []
    index = 0
    for row in A:
        matrix_shift.append(np.roll(row,index))
        index -= 1
    return np.array(matrix_shift)

# inv_shiftRow
def inv_shift_row(A):
    matrix_shift = []
    index = 0
    for row in A:
        matrix_shift.append(np.roll(row,index))
        index += 1
    return np.array(matrix_shift)


# def galois multiplication:
def galois_mul(hex_num1, hex_num2):
    if int(hex_num1, 16) == 0 or int(hex_num2, 16) == 0:
        return hex(0)[2:]
    elif int(hex_num1, 16) == 01:
        return hex_num2
    elif int(hex_num2, 16) == 01:
        return hex_num1
    else:
        E_table = [[0x01, 0x03, 0x05, 0x0f, 0x11, 0x33, 0x55, 0xff, 0x1a, 0x2e, 0x72, 0x96, 0xa1, 0xf8, 0x13, 0x35],
                   [0x5f, 0xe1, 0x38, 0x48, 0xd8, 0x73, 0x95, 0xa4, 0xf7, 0x02, 0x06, 0x0a, 0x1e, 0x22, 0x66, 0xaa],
                   [0xe5, 0x34, 0x5c, 0xe4, 0x37, 0x59, 0xeb, 0x26, 0x6a, 0xbe, 0xd9, 0x70, 0x90, 0xab, 0xe6, 0x31],
                   [0x53, 0xf5, 0x04, 0x0c, 0x14, 0x3c, 0x44, 0xcc, 0x4f, 0xd1, 0x68, 0xb8, 0xd3, 0x6e, 0xb2, 0xcd],
                   [0x4c, 0xd4, 0x67, 0xa9, 0xe0, 0x3b, 0x4d, 0xd7, 0x62, 0xa6, 0xf1, 0x08, 0x18, 0x28, 0x78, 0x88],
                   [0x83, 0x9e, 0xb9, 0xd0, 0x6b, 0xbd, 0xdc, 0x7f, 0x81, 0x98, 0xb3, 0xce, 0x49, 0xdb, 0x76, 0x9a],
                   [0xb5, 0xc4, 0x57, 0xf9, 0x10, 0x30, 0x50, 0xf0, 0x0b, 0x1d, 0x27, 0x69, 0xbb, 0xd6, 0x61, 0xa3],
                   [0xfe, 0x19, 0x2b, 0x7d, 0x87, 0x92, 0xad, 0xec, 0x2f, 0x71, 0x93, 0xae, 0xe9, 0x20, 0x60, 0xa0],
                   [0xfb, 0x16, 0x3a, 0x4e, 0xd2, 0x6d, 0xb7, 0xc2, 0x5d, 0xe7, 0x32, 0x56, 0xfa, 0x15, 0x3f, 0x41],
                   [0xc3, 0x5e, 0xe2, 0x3d, 0x47, 0xc9, 0x40, 0xc0, 0x5b, 0xed, 0x2c, 0x74, 0x9c, 0xbf, 0xda, 0x75],
                   [0x9f, 0xba, 0xd5, 0x64, 0xac, 0xef, 0x2a, 0x7e, 0x82, 0x9d, 0xbc, 0xdf, 0x7a, 0x8e, 0x89, 0x80],
                   [0x9b, 0xb6, 0xc1, 0x58, 0xe8, 0x23, 0x65, 0xaf, 0xea, 0x25, 0x6f, 0xb1, 0xc8, 0x43, 0xc5, 0x54],
                   [0xfc, 0x1f, 0x21, 0x63, 0xa5, 0xf4, 0x07, 0x09, 0x1b, 0x2d, 0x77, 0x99, 0xb0, 0xcb, 0x46, 0xca],
                   [0x45, 0xcf, 0x4a, 0xde, 0x79, 0x8b, 0x86, 0x91, 0xa8, 0xe3, 0x3e, 0x42, 0xc6, 0x51, 0xf3, 0x0e],
                   [0x12, 0x36, 0x5a, 0xee, 0x29, 0x7b, 0x8d, 0x8c, 0x8f, 0x8a, 0x85, 0x94, 0xa7, 0xf2, 0x0d, 0x17],
                   [0x39, 0x4b, 0xdd, 0x7c, 0x84, 0x97, 0xa2, 0xfd, 0x1c, 0x24, 0x6c, 0xb4, 0xc7, 0x52, 0xf6, 0x01]]

        L_table = [[0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03],
                   [0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1],
                   [0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78],
                   [0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e],
                   [0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38],
                   [0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10],
                   [0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba],
                   [0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57],
                   [0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8],
                   [0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0],
                   [0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7],
                   [0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d],
                   [0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1],
                   [0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab],
                   [0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5],
                   [0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07]]

        first_part = (L_table[int(hex_num1[0], 16)][int(hex_num1[1], 16)] + L_table[int(hex_num2[0], 16)][int(hex_num2[1], 16)]) % 255

        second_part = hex(first_part)[2:]
        if len(second_part) < 2:
            second_part = "0" + second_part

        return hex(E_table[int(second_part[0], 16)][int(second_part[1], 16)])[2:]


# Mix columns
def mix_columns(A):
    MC_matrix = [["02", "03", "01", "01"],
                 ["01", "02", "03", "01"],
                 ["01", "01", "02", "03"],
                 ["03", "01", "01", "02"]]

    state = A.T
    mix_columns_matrix = []

    for st in state:
        final_galois = []
        for row in xrange(len(MC_matrix)):
            current_state = []
            for col in xrange(len(MC_matrix)):
                current_state.append(galois_mul(st[col], MC_matrix[row][col]))
            reslt = int(current_state.pop(),16)
            for a in current_state:
                reslt^= int(a,16)
            final_galois.append(hex(reslt)[2:] if len(hex(reslt)[2:]) == 2 else "0"+hex(reslt)[2:])
        mix_columns_matrix.append(final_galois)

    return np.array(mix_columns_matrix).T


# Inv Mix columns
def inv_mix_columns(A):
    MC_matrix = [["0e", "0b", "0d", "09"],
                 ["09", "0e", "0b", "0d"],
                 ["0d", "09", "0e", "0b"],
                 ["0b", "0d", "09", "0e"]]

    state = A.T
    mix_columns_matrix = []

    for st in state:
        final_galois = []
        for row in xrange(len(MC_matrix)):
            current_state = []
            for col in xrange(len(MC_matrix)):
                current_state.append(galois_mul(st[col], MC_matrix[row][col]))
            reslt = int(current_state.pop(),16)
            for a in current_state:
                reslt^= int(a,16)
            final_galois.append(hex(reslt)[2:] if len(hex(reslt)[2:]) == 2 else "0"+hex(reslt)[2:])
        mix_columns_matrix.append(final_galois)

    return np.array(mix_columns_matrix).T

def fill_to128(string_to_expand):
    size = int(math.ceil(len(string_to_expand)/float(16)) * 16)
    return (string_to_expand * ((size/len(string_to_expand))+1))[:size]


# Encrypt message
def encrypt_message(clear_text, key_test):
    keys = key_generator(key_test)
    initial_round = add_round_key(make_state_message(clear_text), keys[0])
    current_state = initial_round

    for index in xrange(1,10):
        #print index, "-------------------------------"
        current_state = subbytes_matrix_convert(current_state)
        #print current_state, "SB"
        current_state = shift_row(current_state)
        #print current_state, "SR"
        current_state = mix_columns(current_state)
        #print current_state, "MC"
        current_state = add_round_key(current_state, keys[index])

    # Last ROUND
    current_state = subbytes_matrix_convert(current_state)
    #print current_state, "SB"
    current_state = shift_row(current_state)
    #print current_state, "SR"

    # Final encryption matrix
    encrypted_message = add_round_key(current_state, keys[len(keys)-1]).T
    # Matrix convert into letters
    cipher_text = []
    for row in encrypted_message:
        for col in row:
            cipher_text.append(col)

    return "".join(cipher_text)

def decrypt_message(encrypted_text, key_test):
    keys = key_generator(key_test)
    initial_round = add_round_key(make_state_message(encrypted_text),keys[len(keys)-1])
    current_state = inv_shift_row(initial_round)
    current_state = inv_subbytes_matrix_convert(current_state)


    for index in xrange(9,0,-1):
        current_state = add_round_key(current_state, keys[index])
        current_state = inv_mix_columns(current_state)
        current_state = inv_shift_row(current_state)
        current_state = inv_subbytes_matrix_convert(current_state)

    # Final encryption matrix
    decrypted_message = add_round_key(current_state, keys[0]).T

    # Matrix convert into letters
    cipher_text = []
    for row in decrypted_message:
        for col in row:
            cipher_text.append(col.decode('hex'))

    return "".join(cipher_text)


def AES_encription(plain_text, key):
    text = fill_to128(plain_text)
    plain_blocks = list(re.findall('.{16}', text))
    key_test = convert_letter_to_hex(key[:16])

    encrypted_blocks = []

    for block in plain_blocks:
        encrypted_blocks.append(encrypt_message(block, key_test))

    return encrypted_blocks

def AES_decription(encrypted_blocks, key, size):
    key_test = convert_letter_to_hex(key[:16])
    decrypted_text = ""

    for block in encrypted_blocks:
        decrypted_text += decrypt_message(block.decode('hex'), key_test)

    return decrypted_text[:size]

message_test = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis auctor magna dolor, varius ullamcorper justo imperdiet sit amet. Vestibulum justo tellus, aliquet congue elit eu, finibus hendrerit lacus. Curabitur lobortis sodales lorem, sed consectetur erat porttitor sit amet. Sed enim eros, pellentesque quis malesuada non, pretium in risus. Morbi tincidunt euismod arcu ut interdum. Nullam vel interdum nisi. Quisque a tempor elit. Aliquam eget risus dictum, aliquet mi at, fringilla orci. Donec eu erat quis quam accumsan gravida. Cras vel lacus ut metus dignissim pellentesque eu at purus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Aenean aliquam nisi odio, vel ultricies lacus finibus placerat."

#key_test = "2b7e151628aed2a6abf7158809cf4f3c"
key_test = "Neque porro quisquam est qui dolorem"


print "Plain text: ", message_test
encrypted = AES_encription(message_test, key_test)
print "Encrypted text: "
for i in xrange(len(encrypted)):
    print i,":",encrypted[i].decode('hex').decode("iso-8859-1")
print "Decrypted text: ", AES_decription(encrypted,key_test,len(message_test)).decode("iso-8859-1")

